package importers_test

import (
	accountsv1 "buf.build/gen/go/xskydev/go-money-pb/protocolbuffers/go/gomoneypb/accounts/v1"
	importv1 "buf.build/gen/go/xskydev/go-money-pb/protocolbuffers/go/gomoneypb/import/v1"
	transactionsv1 "buf.build/gen/go/xskydev/go-money-pb/protocolbuffers/go/gomoneypb/transactions/v1"
	v1 "buf.build/gen/go/xskydev/go-money-pb/protocolbuffers/go/gomoneypb/v1"
	"context"
	_ "embed"
	"encoding/json"
	"github.com/ft-t/go-money/pkg/accounts"
	"github.com/ft-t/go-money/pkg/configuration"
	"github.com/ft-t/go-money/pkg/currency"
	"github.com/ft-t/go-money/pkg/database"
	"github.com/ft-t/go-money/pkg/importers"
	"github.com/ft-t/go-money/pkg/mappers"
	"github.com/ft-t/go-money/pkg/testingutils"
	"github.com/ft-t/go-money/pkg/transactions"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"gorm.io/gorm"
	"net/http"
	"os"
	"testing"
	"time"
)

var gormDB *gorm.DB
var cfg *configuration.Configuration

func TestMain(m *testing.M) {
	cfg = configuration.GetConfiguration()
	gormDB = database.GetDb(database.DbTypeMaster)

	os.Exit(m.Run())
}

//go:embed testdata/accounts.json
var accountsByteData []byte

//go:embed testdata/ff_withdrawal.csv
var ffWithdrawalByteData []byte

//go:embed testdata/ff_open_balance_debt.csv
var ffOpenBalanceDebtByteData []byte

//go:embed testdata/ff_open_balance.csv
var ffOpenBalanceByteData []byte

//go:embed testdata/ff_reconciliation.csv
var ffReconciliationByteData []byte

//go:embed testdata/ff_reconciliation_plus.csv
var ffReconciliationPlusByteData []byte

//go:embed testdata/ff_transfer.csv
var ffTransferByteData []byte

//go:embed testdata/ff_withdrawal_debt.csv
var ffWithdrawalDebt []byte

//go:embed testdata/rates.json
var ratesByteData []byte

func TestFireflyImport(t *testing.T) {
	assert.NoError(t, testingutils.FlushAllTables(cfg.Db))

	var rates []*database.Currency
	assert.NoError(t, json.Unmarshal(ratesByteData, &rates))

	assert.NoError(t, gormDB.Create(&rates).Error)

	var accountsData []*database.Account
	assert.NoError(t, json.Unmarshal(accountsByteData, &accountsData))

	assert.NoError(t, gormDB.Create(&accountsData).Error)

	t.Run("basic multi currency withdrawal", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		txSvc.EXPECT().CreateBulkInternal(gomock.Any(), gomock.Any(), gomock.Any()).
			DoAndReturn(func(ctx context.Context, requests []*transactions.BulkRequest, db *gorm.DB) ([]*transactionsv1.CreateTransactionResponse, error) {
				assert.Len(t, requests, 1)

				tx := requests[0].Req.Transaction.(*transactionsv1.CreateTransactionRequest_Withdrawal)

				txDate := requests[0].Req.TransactionDate.AsTime().Format(time.RFC3339)
				assert.EqualValues(t, "2025-06-17T13:07:46Z", txDate)

				assert.EqualValues(t, tx.Withdrawal.SourceCurrency, "UAH")
				assert.EqualValues(t, *tx.Withdrawal.ForeignCurrency, "PLN")

				assert.EqualValues(t, "-964.44", tx.Withdrawal.SourceAmount)
				assert.EqualValues(t, "-83.81", *tx.Withdrawal.ForeignAmount)

				assert.EqualValues(t, accountsData[0].ID, tx.Withdrawal.SourceAccountId)

				assert.EqualValues(t, "firefly_2805", *requests[0].Req.InternalReferenceNumber)

				assert.EqualValues(t, []int32{1}, requests[0].Req.TagIds)

				return []*transactionsv1.CreateTransactionResponse{
					{
						Transaction: &v1.Transaction{
							InternalReferenceNumber: requests[0].Req.InternalReferenceNumber,
						},
					},
				}, nil
			})

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffWithdrawalByteData,
			Accounts: accountsData,
			Tags: map[string]*database.Tag{
				"Grocery": {
					ID: 1,
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

	t.Run("open balance (debt)", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		txSvc.EXPECT().CreateBulkInternal(gomock.Any(), gomock.Any(), gomock.Any()).
			DoAndReturn(func(ctx context.Context, requests []*transactions.BulkRequest, db *gorm.DB) ([]*transactionsv1.CreateTransactionResponse, error) {
				assert.Len(t, requests, 1)

				tx := requests[0].Req.Transaction.(*transactionsv1.CreateTransactionRequest_Withdrawal)

				assert.EqualValues(t, tx.Withdrawal.SourceCurrency, "PLN")

				assert.EqualValues(t, "-3900", tx.Withdrawal.SourceAmount)

				assert.EqualValues(t, accountsData[1].ID, tx.Withdrawal.SourceAccountId)

				assert.EqualValues(t, "firefly_1869", *requests[0].Req.InternalReferenceNumber)

				return []*transactionsv1.CreateTransactionResponse{
					{
						Transaction: &v1.Transaction{
							InternalReferenceNumber: requests[0].Req.InternalReferenceNumber,
						},
					},
				}, nil
			})

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffOpenBalanceDebtByteData,
			Accounts: accountsData,
			Tags: map[string]*database.Tag{
				"Grocery": {
					ID: 1,
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

	t.Run("open balance", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		txSvc.EXPECT().CreateBulkInternal(gomock.Any(), gomock.Any(), gomock.Any()).
			DoAndReturn(func(ctx context.Context, requests []*transactions.BulkRequest, db *gorm.DB) ([]*transactionsv1.CreateTransactionResponse, error) {
				assert.Len(t, requests, 1)

				tx := requests[0].Req.Transaction.(*transactionsv1.CreateTransactionRequest_Deposit)

				assert.EqualValues(t, tx.Deposit.DestinationCurrency, "PLN")

				assert.EqualValues(t, "3520.42", tx.Deposit.DestinationAmount)

				assert.EqualValues(t, accountsData[1].ID, tx.Deposit.DestinationAccountId)

				assert.EqualValues(t, "firefly_18691", *requests[0].Req.InternalReferenceNumber)

				return []*transactionsv1.CreateTransactionResponse{
					{
						Transaction: &v1.Transaction{
							InternalReferenceNumber: requests[0].Req.InternalReferenceNumber,
						},
					},
				}, nil
			})

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffOpenBalanceByteData,
			Accounts: accountsData,
			Tags: map[string]*database.Tag{
				"Grocery": {
					ID: 1,
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

	t.Run("reconciliation (minus)", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		txSvc.EXPECT().CreateBulkInternal(gomock.Any(), gomock.Any(), gomock.Any()).
			DoAndReturn(func(ctx context.Context, requests []*transactions.BulkRequest, db *gorm.DB) ([]*transactionsv1.CreateTransactionResponse, error) {
				assert.Len(t, requests, 1)

				tx := requests[0].Req.Transaction.(*transactionsv1.CreateTransactionRequest_Reconciliation)

				assert.EqualValues(t, "USD", tx.Reconciliation.DestinationCurrency)

				assert.EqualValues(t, "-296", tx.Reconciliation.DestinationAmount)

				assert.EqualValues(t, accountsData[2].ID, tx.Reconciliation.DestinationAccountId)

				assert.EqualValues(t, "firefly_2848", *requests[0].Req.InternalReferenceNumber)

				return []*transactionsv1.CreateTransactionResponse{
					{
						Transaction: &v1.Transaction{
							InternalReferenceNumber: requests[0].Req.InternalReferenceNumber,
						},
					},
				}, nil
			})

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffReconciliationByteData,
			Accounts: accountsData,
			Tags: map[string]*database.Tag{
				"Grocery": {
					ID: 1,
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

	t.Run("reconciliation (plus)", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		txSvc.EXPECT().CreateBulkInternal(gomock.Any(), gomock.Any(), gomock.Any()).
			DoAndReturn(func(ctx context.Context, requests []*transactions.BulkRequest, db *gorm.DB) ([]*transactionsv1.CreateTransactionResponse, error) {
				assert.Len(t, requests, 1)

				tx := requests[0].Req.Transaction.(*transactionsv1.CreateTransactionRequest_Reconciliation)

				assert.EqualValues(t, "USD", tx.Reconciliation.DestinationCurrency)

				assert.EqualValues(t, "49.37", tx.Reconciliation.DestinationAmount)

				assert.EqualValues(t, accountsData[2].ID, tx.Reconciliation.DestinationAccountId)

				assert.EqualValues(t, "firefly_2830", *requests[0].Req.InternalReferenceNumber)

				return []*transactionsv1.CreateTransactionResponse{
					{
						Transaction: &v1.Transaction{
							InternalReferenceNumber: requests[0].Req.InternalReferenceNumber,
						},
					},
				}, nil
			})

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffReconciliationPlusByteData,
			Accounts: accountsData,
			Tags: map[string]*database.Tag{
				"Grocery": {
					ID: 1,
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

	t.Run("transfer (same currency)", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		txSvc.EXPECT().CreateBulkInternal(gomock.Any(), gomock.Any(), gomock.Any()).
			DoAndReturn(func(ctx context.Context, requests []*transactions.BulkRequest, db *gorm.DB) ([]*transactionsv1.CreateTransactionResponse, error) {
				assert.Len(t, requests, 1)

				tx := requests[0].Req.Transaction.(*transactionsv1.CreateTransactionRequest_TransferBetweenAccounts)

				assert.EqualValues(t, accountsData[2].ID, tx.TransferBetweenAccounts.SourceAccountId)
				assert.EqualValues(t, "-1000", tx.TransferBetweenAccounts.SourceAmount)
				assert.EqualValues(t, "USD", tx.TransferBetweenAccounts.SourceCurrency)

				assert.EqualValues(t, "USD", tx.TransferBetweenAccounts.DestinationCurrency)
				assert.EqualValues(t, "1000", tx.TransferBetweenAccounts.DestinationAmount)

				assert.EqualValues(t, accountsData[3].ID, tx.TransferBetweenAccounts.DestinationAccountId)

				assert.EqualValues(t, "firefly_2856", *requests[0].Req.InternalReferenceNumber)

				return []*transactionsv1.CreateTransactionResponse{
					{
						Transaction: &v1.Transaction{
							InternalReferenceNumber: requests[0].Req.InternalReferenceNumber,
						},
					},
				}, nil
			})

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffTransferByteData,
			Accounts: accountsData,
			Tags: map[string]*database.Tag{
				"Grocery": {
					ID: 1,
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

	t.Run("debt withdrawal -> transfer", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		txSvc.EXPECT().CreateBulkInternal(gomock.Any(), gomock.Any(), gomock.Any()).
			DoAndReturn(func(ctx context.Context, requests []*transactions.BulkRequest, db *gorm.DB) ([]*transactionsv1.CreateTransactionResponse, error) {
				assert.Len(t, requests, 1)

				tx := requests[0].Req.Transaction.(*transactionsv1.CreateTransactionRequest_TransferBetweenAccounts)

				assert.EqualValues(t, 55, *requests[0].Req.CategoryId)
				assert.EqualValues(t, accountsData[2].ID, tx.TransferBetweenAccounts.SourceAccountId)
				assert.EqualValues(t, "-200", tx.TransferBetweenAccounts.SourceAmount)
				assert.EqualValues(t, "USD", tx.TransferBetweenAccounts.SourceCurrency)

				assert.EqualValues(t, "USD", tx.TransferBetweenAccounts.DestinationCurrency)
				assert.EqualValues(t, "200", tx.TransferBetweenAccounts.DestinationAmount)
				assert.EqualValues(t, accountsData[4].ID, tx.TransferBetweenAccounts.DestinationAccountId)

				assert.EqualValues(t, "firefly_2004", *requests[0].Req.InternalReferenceNumber)

				return []*transactionsv1.CreateTransactionResponse{
					{
						Transaction: &v1.Transaction{
							InternalReferenceNumber: requests[0].Req.InternalReferenceNumber,
						},
					},
				}, nil
			})

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffWithdrawalDebt,
			Accounts: accountsData,
			Categories: map[string]*database.Category{
				"Debt repayment": {
					ID:   55,
					Name: "Debt repayment",
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
	})

}

func TestSkipDuplicate(t *testing.T) {
	assert.NoError(t, testingutils.FlushAllTables(cfg.Db))

	var rates []*database.Currency
	assert.NoError(t, json.Unmarshal(ratesByteData, &rates))

	assert.NoError(t, gormDB.Create(&rates).Error)

	var accountsData []*database.Account
	assert.NoError(t, json.Unmarshal(accountsByteData, &accountsData))

	assert.NoError(t, gormDB.Create(&accountsData).Error)

	t.Run("skip duplicate transactions", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		tx := &database.ImportDeduplication{
			ImportSource: importv1.ImportSource_IMPORT_SOURCE_FIREFLY,
			Key:          "firefly_2805",
		}
		assert.NoError(t, gormDB.Create(&tx).Error)

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     ffWithdrawalByteData,
			Accounts: accountsData,
			Tags: map[string]*database.Tag{
				"Grocery": {
					ID: 1,
				},
			},
		})

		assert.NoError(t, err)
		assert.NotNil(t, result)
		assert.EqualValues(t, result.DuplicateCount, 1)
	})
}

func TestFireflyNoData(t *testing.T) {
	t.Run("no data", func(t *testing.T) {
		txSvc := NewMockTransactionSvc(gomock.NewController(t))

		importer := importers.NewFireflyImporter(txSvc)

		result, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     []byte{},
			Accounts: nil,
			Tags:     nil,
		})

		assert.Error(t, err)
		assert.Nil(t, result)
		assert.EqualError(t, err, "no records found in CSV data")
	})
}

func TestFireflyIntegration(t *testing.T) {
	t.Skip("todo")

	assert.NoError(t, testingutils.FlushAllTables(cfg.Db))
	data, err := os.ReadFile("C:\\Users\\iqpir\\Downloads\\2025_06_26_transaction_export.csv")
	assert.NoError(t, err)

	accountsData, err := os.ReadFile("C:\\Users\\iqpir\\Result_17.json")
	assert.NoError(t, err)

	var bulkAccounts []*accountsv1.CreateAccountRequest
	assert.NoError(t, json.Unmarshal(accountsData, &bulkAccounts))

	m := mappers.NewMapper(&mappers.MapperConfig{
		DecimalSvc: currency.NewDecimalService(),
	})

	accountSvc := accounts.NewService(&accounts.ServiceConfig{
		MapperSvc: m,
	})
	_, err = accountSvc.CreateBulk(context.TODO(), &accountsv1.CreateAccountsBulkRequest{
		Accounts: bulkAccounts,
	})
	assert.NoError(t, err)

	var allAccounts []*database.Account
	assert.NoError(t, gormDB.Find(&allAccounts).Error)

	cur := currency.NewSyncer(http.DefaultClient, transactions.NewBaseAmountService("USD"), configuration.CurrencyConfig{
		BaseCurrency: "USD",
	})
	assert.NoError(t, cur.Sync(context.TODO(), "http://go-money-exchange-rates.s3-website.eu-north-1.amazonaws.com/latest.json"))

	converter := currency.NewConverter("USD")

	txSvc := transactions.NewService(&transactions.ServiceConfig{
		StatsSvc:             transactions.NewStatService(),
		MapperSvc:            m,
		CurrencyConverterSvc: converter,
	})
	importer := importers.NewFireflyImporter(txSvc)

	result, err := importer.Import(context.TODO(), &importers.ImportRequest{
		Data:     data,
		Accounts: allAccounts,
	})

	assert.NoError(t, err)
	assert.NotNil(t, result)
}

func TestFireflyImport_FailCases(t *testing.T) {
	assert.NoError(t, testingutils.FlushAllTables(cfg.Db))

	var accountsData []*database.Account
	assert.NoError(t, json.Unmarshal(accountsByteData, &accountsData))
	assert.NoError(t, gormDB.Create(&accountsData).Error)

	txSvc := NewMockTransactionSvc(gomock.NewController(t))
	importer := importers.NewFireflyImporter(txSvc)

	t.Run("missing source account", func(t *testing.T) {
		// Withdrawal with unknown account name
		csv := `h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13,h14,h15,h16,h17,h18,h19,h20,h21,h22,h23,h24,h25
1,2,3,4,5,6,Withdrawal,100,50,USD,PLN,desc,2024-06-27T12:00:00+00:00,UnknownAccount,notes,normal,17,18,19,category,21,22,tag1,notes2,extra`
		_, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     []byte(csv),
			Accounts: accountsData,
		})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "source account not found")
	})

	t.Run("currency mismatch", func(t *testing.T) {
		// Withdrawal with wrong currency
		csv := `h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13,h14,h15,h16,h17,h18,h19,h20,h21,h22,h23,h24,h25
1,2,3,4,5,6,Withdrawal,100,50,PLN,PLN,desc,2024-06-27T12:00:00+00:00,` + accountsData[0].Name + `,notes,normal,17,18,19,category,21,22,tag1,notes2,extra`
		_, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     []byte(csv),
			Accounts: accountsData,
		})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "source account currency")
	})

	t.Run("unsupported operation type", func(t *testing.T) {
		csv := `h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13,h14,h15,h16,h17,h18,h19,h20,h21,h22,h23,h24,h25
1,2,3,4,5,6,UnknownType,100,50,USD,PLN,desc,2024-06-27T12:00:00+00:00,` + accountsData[0].Name + `,notes,normal,17,18,19,category,21,22,tag1,notes2,extra`
		_, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     []byte(csv),
			Accounts: accountsData,
		})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "unsupported operation type")
	})

	t.Run("invalid amount", func(t *testing.T) {
		csv := `h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13,h14,h15,h16,h17,h18,h19,h20,h21,h22,h23,h24,h25
1,2,3,4,5,6,Withdrawal,notanumber,50,USD,PLN,desc,2024-06-27T12:00:00+00:00,` + accountsData[0].Name + `,notes,normal,17,18,19,category,21,22,tag1,notes2,extra`
		_, err := importer.Import(context.TODO(), &importers.ImportRequest{
			Data:     []byte(csv),
			Accounts: accountsData,
		})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to parse amount")
	})
}

func TestParseDate(t *testing.T) {
	input := "2025-06-17T15:07:46+02:00"
	ff := importers.NewFireflyImporter(nil)

	t.Run("with local", func(t *testing.T) {
		resp, err := ff.ParseDate(input, false)
		assert.NoError(t, err)
		assert.Equal(t, input, resp.Format(time.RFC3339))
	})

	t.Run("force utc", func(t *testing.T) {
		resp, err := ff.ParseDate(input, true)
		assert.NoError(t, err)
		assert.Equal(t, "2025-06-17T15:07:46Z", resp.Format(time.RFC3339))
	})
}
